=begin
Массив A состоит из N целых чисел. 
Тройка чисел (P, Q, R) называется треугольником 
если 0 ≤ P < Q < R < N и:

A[P] + A[Q] > A[R],
A[Q] + A[R] > A[P],
A[R] + A[P] > A[Q].

Для примера рассмотрим массив A:
  A[0] = 10    A[1] = 2    A[2] = 5
  A[3] = 1     A[4] = 8    A[5] = 20
Тройка (0, 2, 4) является треугольником.

Необходимо написать функцию:
def solution(A);
которая для массива целых чисел из N элементов 
вернет 1 если существует треугольник в массиве и 
вернет 0 в обратном случае. 

Для примера массив A:
  A[0] = 10    A[1] = 2    A[2] = 5
  A[3] = 1     A[4] = 8    A[5] = 20
функция должна вернуть 1 (пример выше). 

Для такого массива:
  A[0] = 10    A[1] = 50    A[2] = 5
  A[3] = 1
функция должна вернуть 0.

Предполагаем:

N  число в диапазоне [0..1,000,000];
каждый элемент массива A целое число в диапазоне [−2,147,483,648..2,147,483,647].
Требования по сложности алгоритма:

в худшем случае время выполнения должно быть O(N*log(N));
в худшем случае памяти должно использоваться O(N) .
Элементы массива можно модифицировать.
=end


=begin
Идея решения
Для начала, конечно, отсортируем массив за O(N*log(N))	
рассмотрим в нём тройку последовательных чисел a <= b <= c
	c + b > a всегда
 	c + a > b всегда
 	a + b > c - под вопросом
  		если да, то найден треугольник
  		если нет, то a + b не превзойдёт никакое число d >= c
  			значит об а уже можно забыть и переходить к следующей тройке b,c,d
=end

def solution(ar)
	ar.sort!
	0.upto (ar.length - 3) do |n|
		a = ar[n]; b = ar[n + 1]; c = ar[n + 2]
		return 1 if a + b > c
	end
	return 0
end

examples = [
	[10, 2, 5, 1, 8, 20],
	[10, 50, 5, 1],
	[3, 4, 7],
	[-3, -4, -5],
	[0, 0, 0]
]

examples.each do |arr|
	puts arr.sort.to_s + " -> " + solution(arr).to_s
end